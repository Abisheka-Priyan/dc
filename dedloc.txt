//cent


from collections import defaultdict

class graph:
    def __init__(self):
        self.graph = defaultdict(list)
    def addEdge(self, u, v):
        self.graph[u].append(v)
    def printgraph(self):
        for i in self.graph:
            print(i, end=" ")
            for j in self.graph[i]:
                print("->", j, end=" ")
            print()

s1 = graph()
s1.addEdge(3, 2)
s1.addEdge(2,1)

s2 = graph()
s2.addEdge(1, 2)

# central graph that combines s1 and s2
def central_graph(s1, s2):
    s3 = graph()
    for i in s1.graph:
        for j in s1.graph[i]:
            s3.addEdge(i, j)
    for i in s2.graph:
        for j in s2.graph[i]:
            s3.addEdge(i, j)
    return s3

s3 = central_graph(s1, s2)
# print(s3.graph[1])
# print(s3.graph)
#find cycle in s3

s1.printgraph()
print()
s2.printgraph()
print()
s3.printgraph()

def dfs(s3, v, visited):
    visited.add(v)
    for i in s3.graph[v]:
        # print(i)
        if i not in visited:
            if dfs(s3, i, visited):
                return True
        else:
            return True
    return False

def find_cycle(s3):
    visited = set()
    for i in s3.graph:
        if i not in visited:
            if dfs(s3, i, visited):
                return True
    return False


if find_cycle(s3):
    print("Deadlock found")
else:
    print("No deadlock")

def printgraph(s1):
    #print graph in a graphical way
    for i in s1.graph:
        print(i, end=" ")
        for j in s1.graph[i]:
            print("->", j, end=" ")
        print()


-----------------------------------------------


//hier

# python program to demonstrate the use of heirachial deadlock detection
from collections import defaultdict


class graph:
    def __init__(self):
        self.graph = defaultdict(list)

    def addEdge(self, u, v):
        self.graph[u].append(v)

    def printgraph(self):
        for i in self.graph:
            print(i, end="->")
            for j in self.graph[i]:
                print(",", j, end=" ")
            print()


n_sites = int(input("Enter the number of sites: "))
site_list = [graph()] * n_sites

# input from user

for i in range(n_sites):
    n = int(input("Enter the number of edges for site {}: ".format(i+1)))
    for j in range(n):
        u, v = map(int, input("Enter the edge (a->b) :").split())
        site_list[i].addEdge(u, v)

# site_list[0].printgraph()


def combine(s1, s2):
    s3 = graph()
    for i in s1.graph:
        for j in s1.graph[i]:
            s3.addEdge(i, j)
    for i in s2.graph:
        for j in s2.graph[i]:
            s3.addEdge(i, j)
    return s3


def dfs(s3, v, visited):
    visited.add(v)
    for i in s3.graph[v]:
        if i not in visited:
            if dfs(s3, i, visited):
                return True
        else:
            return True
    return False

def find_cycle(s3):
    visited = set()
    for i in s3.graph:
        if i not in visited:
            if dfs(s3, i, visited):
                return True
    return False

def detect_deadlock(site_list):
    while len(site_list) > 1:
        local_cordinator = []
        for i in range(0, len(site_list), 2):
            if i+1 < len(site_list):
                local_cordinator.append(combine(site_list[i], site_list[i+1]))
                lc = local_cordinator[-1]
                print(f"Local Coordinator of {i}, {i+1}")
                lc.printgraph()
                if find_cycle(lc):
                    print(f"Deadlock detected at coordinator")
                    lc.printgraph()
                    return
            else:
                local_cordinator.append(site_list[i])
                print("Odd number of sites so this is the last site")
                site_list[i].printgraph()
        site_list = local_cordinator
    print("No deadlock detected")


detect_deadlock(site_list)


-------------------------------------------------------

//probe


from collections import defaultdict
class sl:
    def __init__(self):
        self.gg=defaultdict(list)
    def inh(self,u,v,n):
        n[u].append(v)
    def merge1(self,ss1,ss2):
        ss2=self.gg.copy()
        self.gg.clear()
        for f in(ss1,ss2):
            for k,v in f.items():
                for p in v:
                    self.gg[k].append(p)
    def check(self,di,k):
        for i in di.keys():
            if i==k:
                return 1
        return 0
    def sol(self,k,j):
        ls=[]
        lss=[]
        m={}
        ls.append(k)
        lss.append(k)
        while ls:
            t=ls.pop(0)
            for i in j[t]:
                if i not in m.keys():
                    m[i]=[list((k,t,i))]
                else:
                    m[i].append(list((k,t,i)))
                # print(m)
                if i not in lss:
                    lss.append(i)
                    ls.append(i)
        return m

s=sl()
dh=defaultdict(list)
dr=defaultdict(list)
r=int(input("Enter the number of resources : "))
p=int(input("Enter the number of processes : "))
lss=[]
while(True):
    r1=int(input("Enter the resource : "))
    if r1<0:
        break
    if r1==0 or r1>r:
        print("Enter valid resource")
    q = int(input("Enter the process holding resources : "))
    if q==0 or q>p:
        print("Enter valid process")
    qq = int(input("Enter the process requesting resources : "))
    if qq==0 or qq>p:
        print("Enter valid process")
    w=str(input("Enter the site for the processes : "))
    if w not in lss:
        lss.append(w)
        vars()[w]=defaultdict(list)
    s.inh(q,qq,vars()[w])
    dh[r1].append(q)
    dr[r1].append(qq)
for i in lss:
    print(f"Site {i}:\n{dict(vars()[i])}")
flag1=1
y1=int(input("Enter requesting process: "))
x1=int(input("Enter resource holding process: "))
flag=1
for i in lss:
    if flag==1:
        s.gg=vars()[i].copy()
        flag=0
    else:
        s.merge1(vars()[i],s.gg)
print(f"WFG:\n{dict(s.gg)}")
d1=s.sol(y1,s.gg)
print(f"Probe message received:\n{dict(d1)}")
if(s.check(d1,y1)==1):
    print("Deadlock")
else:
    print("No deadlock")


-----------------------------------------------------------